"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const net = require("net");
const buffer_1 = require("buffer");
class ExtendableError extends Error {
    constructor(message = '', innerException) {
        super(message);
        this.innerException = innerException;
        this.message = message;
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.ExtendableError = ExtendableError;
class RconError extends ExtendableError {
    constructor(message, innerException) {
        super(message, innerException);
        Object.freeze(this);
    }
}
exports.RconError = RconError;
var Defaults;
(function (Defaults) {
    Defaults.PORT = 25575;
    Defaults.TIMEOUT = 5000;
})(Defaults = exports.Defaults || (exports.Defaults = {}));
Object.freeze(Defaults);
class Rcon {
    constructor(config) {
        this.enableConsoleLogging = false;
        this._authPacketId = NaN;
        this._state = 0 /* Disconnected */;
        this._lastRequestId = 0xF4240;
        this._callbacks = new Map();
        this._errors = [];
        this._sessionCount = 0;
        let host = config.host;
        this.host = host = host && host.trim();
        if (!host)
            throw new TypeError('"host" argument cannot be empty');
        this.port = config.port || Defaults.PORT;
        const password = config.password;
        if (!password || !password.trim())
            throw new TypeError('"password" argument cannot be empty');
        this.password = password;
        this.timeout = config.timeout || Defaults.TIMEOUT;
    }
    get errors() {
        return this._errors.slice();
    }
    get state() {
        return this._state;
    }
    connect() {
        const _ = this;
        let p = _._connector;
        if (!p)
            _._connector = p = new Promise((resolve, reject) => {
                _._state = 0.5 /* Connecting */;
                if (_.enableConsoleLogging)
                    console.log(this.toString(), "Connecting...");
                const s = _._socket = net.createConnection(_.port, _.host);
                function cleanup(message, error) {
                    if (error)
                        _._errors.push(error);
                    s.removeAllListeners();
                    if (_._socket == s)
                        _._socket = undefined;
                    if (_._connector == p)
                        _._connector = undefined;
                    if (message) {
                        if (_.enableConsoleLogging)
                            console.error(_.toString(), message);
                        if (message)
                            return new RconError(message, error);
                    }
                }
                // Look for connection failure...
                s.once('error', error => {
                    _._state = -1 /* Refused */;
                    reject(cleanup("Connection refused.", error)); // ** First point of failure.
                });
                // Look for successful connection...
                s.once('connect', () => {
                    s.removeAllListeners('error');
                    _._state = 1 /* Connected */;
                    if (_.enableConsoleLogging)
                        console.log(_.toString(), "Connected. Authorizing ...");
                    s.on('data', data => _._handleResponse(data));
                    s.on('error', error => {
                        _._errors.push(error);
                        if (_.enableConsoleLogging)
                            console.error(_.toString(), error);
                    });
                    _._send(_.password, 3 /* AUTH */).then(() => {
                        _._state = 2 /* Authorized */;
                        if (_.enableConsoleLogging)
                            console.log(_.toString(), "Authorized.");
                        resolve(_);
                    }).catch(error => {
                        _._state = -2 /* Unauthorized */;
                        reject(cleanup("Authorization failed.", error)); // ** Second point of failure.
                    });
                });
                s.once('end', () => {
                    if (_.enableConsoleLogging)
                        console.warn(this.toString(), "Disconnected.");
                    _._state = 0 /* Disconnected */;
                    cleanup();
                });
            });
        return p;
    }
    session(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const sessionId = ++this._sessionCount;
            let rcon;
            try {
                rcon = yield this.connect();
                return yield context(rcon, sessionId);
            }
            finally {
                this._sessionCount--;
                if (!this._sessionCount && rcon)
                    rcon.disconnect();
            }
        });
    }
    toString() {
        return `RCON: ${this.host}:${this.port}`;
    }
    disconnect() {
        const s = this._socket;
        this._callbacks.clear();
        if (s)
            s.end();
        this._socket = undefined;
        this._connector = undefined;
    }
    _handleResponse(data) {
        const len = data.readInt32LE(0);
        if (!len)
            throw new RconError('Received empty response package');
        let id = data.readInt32LE(4);
        const type = data.readInt32LE(8);
        const callbacks = this._callbacks;
        const authId = this._authPacketId;
        if (id === -1 && !isNaN(authId) && type === 2 /* RESPONSE_AUTH */) {
            if (callbacks.has(authId)) {
                id = authId;
                this._authPacketId = NaN;
                callbacks.get(authId)(null, new RconError('Authentication failed.'));
            }
        }
        else if (callbacks.has(id)) {
            let str = data.toString('utf8', 12, len + 2);
            if (str.charAt(str.length - 1) === '\n')
                str = str.substring(0, str.length - 1);
            callbacks.get(id)(str);
        }
        callbacks.delete(id); // Possibly superfluous but best to be sure.
    }
    send(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this._connector || this._state <= 0)
                throw new RconError('Instance is not connected.');
            yield this._connector;
            return yield this._send(data, 2 /* COMMAND */);
        });
    }
    _send(data, cmd) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const s = this._socket;
            if (!s || this._state <= 0)
                throw new RconError('Instance was disconnected.');
            const length = buffer_1.Buffer.byteLength(data);
            const id = ++this._lastRequestId;
            if (cmd === 3 /* AUTH */)
                this._authPacketId = id;
            const buf = buffer_1.Buffer.allocUnsafe(length + 14);
            buf.writeInt32LE(length + 10, 0);
            buf.writeInt32LE(id, 4); // Not sure how this is used or needed.
            buf.writeInt32LE(cmd, 8);
            buf.write(data, 12);
            buf.fill(0x00, length + 12);
            yield s.write(buf, 'binary');
            return yield new Promise((resolve, reject) => {
                const cleanup = () => {
                    clearTimeout(timeout);
                    s.removeListener('end', onEnded);
                    this._callbacks.delete(id);
                    if (cmd === 3 /* AUTH */)
                        this._authPacketId = NaN;
                };
                const timeout = setTimeout(() => {
                    cleanup();
                    reject(new RconError('Request timed out'));
                }, this.timeout);
                const onEnded = () => {
                    cleanup();
                    reject(new RconError('Disconnected before response.'));
                };
                s.once('end', onEnded);
                this._callbacks.set(id, (data, err) => {
                    cleanup();
                    if (err)
                        reject(err);
                    if (data == null)
                        reject(new RconError("No data returned."));
                    else
                        resolve(data);
                });
            });
        });
    }
}
exports.Rcon = Rcon;
exports.default = Rcon;
//# sourceMappingURL=rcon.js.map